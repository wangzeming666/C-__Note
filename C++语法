先说明，绝大多数内容从书上摘抄总结，仅学习使用。如有侵权行为，望告知。


C++ 程序有一个或多个被称为函数的模块组成。程序从 main() 函数开始执行，必不可少。

函数由函数头和函数体组成，函数应该提供原型。函数头指出函数的返回值的类型和函数传递的参数类型，无返回值或参数时可使用viod。函数体由花括号内的各种语句组成。

C++ 语句大致分为一下几种类型：
                                                          声明语句，定义函数中变量使用的名称和类型。
                                                          赋值语句，使用赋值运算符 = 为变量赋值
                                                          消息语句，将消息发送给对象，激发某种行为
                                                          函数调用，执行函数。被调用的函数执行完毕后，程序返回到函数调用语句之后继续执行。
                                                          函数原型，声明函数的返回类型、函数接受的参数数量和类型。
                                                          返回语句，将一个值从被调用的函数那里返回到调用函数中。

类是用户定义的数据类型规范，它详细描述了如何表示信息以及可对数据执行的操作。对象是根据类规范创建的实体，就像简单变量是根据数据类型描述创建的实体一样。对于类的定义， Python 也是一样的。类可以看作是由一种相似事物的共同特征组成的特征集合，如生物学中的同纲同属。创建实例的时候无比方便，抄袭的时候也是真方便。

C++ 提供了两个用于处理输入和输出的预定义对象，cin 和 cout，他们是 istream 和 ostream 类的实例，这两个类是在 iostream 文件中定义的。 ostream 类定义的插入运算符 << 将数据插入到输出流； istream 类定义的抽取运算符 >> 能够从输入流中抽取信息。cin 和 cout 都是智能对象，能够根据上下文自动将信息从一种形式转换为另有一种形式。要使用 iostream 文件中的函数，需要令函数能够访问命名空间。关于命名空间的概念会在后面写。

C++ 可以使用大量的 C 库函数。要使用库函数，应当包含提供函数原型的头文件。

C++ 的基本类型分为两组： 一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整形之间通过存储值时使用的内存量及有无符号来区分。整形从最小到最大依次是：bool, char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long 以及 long long 和 unsigned long long。还有一种 wchar_t 类型，它在这个序列中的位置将取决于实现。

字符通过其数值编码来表示。I/O 系统决定了编码是被解释为字符还是数字。

浮点类型可以表示小数值以及比整形能够表示的值大得多的值。3 种浮点类型分别是 float, double, 和 long double。C++ 确保 float 不比 double 长，而 double 不比 long double 长。通常，float 使用 32 位内存， double 使用 64 位， long double 使用 80 到128 位。

C++ 使用运算符来提供对数字类型的算术运算： 加、减、乘、 除和求膜。当两个运算符对同一个操作数进行操作时，C++ 的优先级和结合性规则可以确定先执行那种操作。

对变量赋值、在运算中使用不同类型、使用强制转换时，C++ 将把值从一种类型转换为另一种类型。由窄向宽转换时是安全的，由宽向窄转换往往会导致数据丢失。

使用合适的类型是非常必要的。

数组、结构和指针是 C++ 的 3 种复合类型。数组可以在一个数据对象中存储多个同类型的值。通过索引或下标，可以访问数组中各个元素。

结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符 . 来访问其中的成员。使用结构的第一步是创建结构模板，它定义结构存储了哪些成员。模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量。

共同体可以储存一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。

指针是被设计用来存储地址的变量。指针指向它存储的地址。指针声明指出了指针指向的对象的类型。对指针应用解除引用运算符，将得到指针指向的位置中的值。

字符串是以空字符为结尾的一些列字符。字符串可以用引号括起的字符常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在 char 数组中，可以用被初始化为指向字符串的 char 指针表示字符串。函数 strlen() 返回字符串的长度，其中不包括空字符。函数 strcpy() 将字符串从一个位置复制到另一个位置。在使用这些函数时，应当包含头文件 cstring 或string.h

头文件 string 支持的 C++ string 类提供了另一种对用户更友好的字符串处理方法。具体地说，string 对象将根据要存储的字符串自动调整大小，用户可以使用赋值运算符来复制字符串。

new 运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指针来访问这块内存。如果数据对象是简单变量，则可以使用解除引用运算符 * 来获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构，则可以用指针解除引用运算符 -> 来访问其成员

指针和数组紧密相关。如果 ar 是数组名，则表达式 ar[i] 被解释为 *（ar+i），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访问 new 分配的数组中的元素

运算符 new 和 delete 允许显示控制何时给数据对象分配内存，何时将内存归还给内存池。自动变量是在函数中声明的变量，而静态变量是在函数外部或者使用关键字 static 声明的变量，这两种变量都不太灵活。自动变量在程序执行到其所属的代码块（通常是函数定义）时产生，在离开代码时终止。静态变量在整个程序周期内都存在。

C++ 98 新增的标准模板库（STL）提供了模板类 vector，它是动态数组的代替品。C++ 提供了模板类 array，他是定长数组的替代品。

C++ 提供了 3 种循环：for 循环、while 循环。如果循环测试条件为 true 或非零，则循环将重复执行一组指令了；如果测试条件为 false 或 0，则结束循环。for 循环和 while 循环都是入口条件循环，这意味着程序将在执行循环体中的语句之前检查测试条件。do while 循环是出口条件循环，这意味着其将在执行循环体中的语句之后检查条件。

每种循环的句法都要求循环体由一条语句组成。然而，这条语句可以是复合语句，也可以是语句块（由花括号括起的多条语句）。

关系表达式对两个值进行比较，常被用作循环测试条件。关系表达式是通过使用 6 种关系运算符之一构成的：<, <=, ==, >=, != 或 =。
关系表达式的结果为 bool 型，值为 true 或 false

许多程序都逐字节的读取文本输入或文本文件，istream 类提供了多种可完成这种工作的方法。如果 ch 是一个 char 变量，则下面的语句将输入中的下一个字符读入到 ch 中：
    cin >> ch
然而，它将会忽略空格、换行符和制表符。下面的成员函数调用读取输入中的下一个字符（不管字符是什么）并将其存储到 ch 中：
    cin.get(ch)
成员函数调用 cin.get() 返回下一个输入字符——包括空格、换行符和制表符，因此可以这样使用：
    ch = cin.get(）

cin.get(char) 成员函数通过返回转换为 false 的 bool 值来指出已到达 EOF，而 cin.get() 成员函数调用则通过返回 EOF 值来指出已经达到 EOF，EOF 是在文件 iostream 中定义的。

嵌套循环是循环中的循环，适用于处理二维数组


以上是各个章节的总结

下面写的是学习笔记，一一细数，简单概念简单叙述，一笔带过。由于 C++ 知识点


预处理器编译指令 #include

cin.get()

关键字void

注释以 // 开头，到行尾结束

C++ 的输入/输出方案涉及 iostream 文件中的多个定义，使用 cin 和 cout 必须包含头文件 #iostream

using编译指令、using声明

运算符重载

endl 重启一行

换行符/n

C++ 源代码风格  每条语句占用一行
                            每个函数都有一个开始花括号和一个结束花括号
                            函数中的语句都相对与花括号进行缩进
                            与函数名称相关的圆括号周围没有空白

C++ 中，所有变量必须声明

程序中的声明语句叫做定义声明语句

符号 = 叫做赋值运算符

C++ 插入运算符 << 将根据其后的数据类型相应的调整行为

输出时， << 运算符将字符串插入到输出流中；输入时，cin 使用 >> 运算符从输入流中抽取字符

类定义描述的是数据格式及其用法，而对象则是根据数据格式规范创建的实体

发送给函数的信息被称为传递给函数，以这种方式发送给函数的值叫做参数。发送给调用函数的值叫做返回值

使用函数之前，C++ 必须知道函数的参数类型和返回值类型。C++ 程序应当为程序中使用的每个函数提供原型

函数原型之与函数就像变量声明之于变量——指出涉及的类型

rand() 函数不接受任何参数，并返回一个随机整数

对于库函数，使用前必须提供其原型

关键字是C++ 专用的，不能用作变量名、函数名

以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。

命名前缀风格。前缀 n 表示整数值，前缀 str/sz 表示以空字符结尾的字符串，b 表示布尔值，p 表示指针，c 表示单个字符

short 至少 16 位
int 至少与 short 一样长
long 至少 32 位，且至少与 int 一样长
long long 至少 64 位，且至少与 long 一样长

8 位单元可以表示 0-255 或 -128到127
16 位单元可以表示 65 536 个不同的值
32 位单元可以表示 4 294 672 296 个不同的值
64 位单元可以表示 18 446 744 073 709 551 616 个不同的值

字节通常指的是 8 位的内存单元。然而C++ 对字节的定义不同，C++ 字节由至少能够容纳实现的基本字符集的相邻位组成，也就是说，可能取值的数目必须等于或超过字符数目。

要创建无符号版本的基本类型，只需要使用关键字 unsigned 来修改声明即可。unsigned 是 unsigned int 的缩写

上溢和下溢

整形字面值。如果第一位为 1~9，十进制。如果第一位是 0，第二位 1~7，八进制。如果前两位为 0x 或 0X，十六进制。对于十六进制数，字符 a~f 和 A~F 表示了 十六进制位，对应为 10~15

char 类型是为了存储字符而设计的。

类定义了如何表示和控制数据。成员函数归类所有，描述了操纵数据的方法。只能通过类的特定对象来使用成员函数。要通过对象使用成员函数，必须用句点将对象名和函数名称连接起来。句点被称为成员运算符

C++ 转义序列的编码。


char 在默认的情况下既不是没有符号，也不是有符号。是否有符号由C++ 实现来决定

创建常量的通用格式为：const type name = value
如果在声明常量时没有提供值，则该常量的值将是不确定的

通常，float 为 32 位，double 为 64 位。long double 为 80、96 或 128 位
float 类型只能表示数字的前 6 位或前 7 位

% 运算符求模。它生成第一个数除以第二个数后的余数

C++ 执行很多类型转换：
将一种算术类型的值赋给另一种算数类型的变量时，C++ 将对值进行转换
表达式包中包含不同的类型时
将参数传递给函数时，C++ 将对值进行转换

C++ 允许将一种类型的值赋给另一种类型的变量。这样做时，值将被转换为接收变量的类型

C++ 将使用大括号的初始化称为列表初始化。列表初始化不允许缩窄

在计算表达式时，C++ 将 bool、char、unsigned char、signed char 和 short 值转换为 int，这些转换称为整型提升

将不同类型进行算数运算时，也会进行转换。较小的类型将被转换为较大的类型。编译器通过校验表来确定在算术表达式中执行的转换

传递参数时的类型转换通常由C++ 函数原型控制

C++ 还允许通过强制类型转换机制显式地进行类型转换。强制转换的通用格式：typeName value

在初始化声明中，如果使用关键字 auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同

数组 array 是一种数据格式，能够存储多个同类型的值。要创建数组，可使用声明语句。数组声明应指出三点：存储在每个元素中的值的类型；数组名；数组中的元素数
事实上，可以将数组中的每个元素看作是一个简单变量
声明数组的通用格式： typeName arrayName[arraySize]
数组的元素数不能是变量
数组从 0 开始编号
C++ 使用带索引的方括号表示法来指定数组元素

必须是特定类型的数组，如 char 数组、float 数组

只有在定义数组时才能使用初始化，以后就不能使用了，也不能将一个数组赋给另一个数组
可以使用下标分别给数组中的元素赋值
初始化时，提供的值可以少于数组的元素数目
如果初始化数组时方括号内为空，C++ 编译器将计算元素个数

C 风格字符串具有一种特殊的性质：以空字符结尾，空字符被写作 \0

只是用一个用引号括起的字符串被称为字符串常量或字符串字面值
用引号括起的字符串隐式的包含结尾的空字符，不用显式地包括它

应确保数组足够大，能够存储字符串中所有字符——包括空字符

字符串常量不能与字符常量互换。字符常量是字符串编码的简写表示

C++ 允许拼接字符串字面值

将字符存储到数组中，最常用的方法有两种：将数组初始化为字符串常量、将键盘或文件输入读入到数组中

strlen() 函数确定字符串的长度
sizeof 运算符指出整个数组的长度

cin 使用空格、制表符和换行符来确定字符串的结束位置。这意味着 cin 在获取字符数组输入时只读取一个单词。读取该单词后，cin 将该字符串放到数组中，并自动在结尾添加空字符。如果输入了一个以上的单词，cin 将获取第一个，余下的留在输入流中等待获取

istream 中的类提供了一些面向行的类成员函数：getlin() 和 get()
这两个函数都读取一行输入，直到到达换行符。随后 getline() 将丢弃换行符，而 get() 将换行符保留在输入队列中
面向行的输入：cin.getline(Name, Size)
                         cin.get(Name, Size)
使用 get() 时，如果获取的第一个字符是换行符，get() 将不能跨过该换行符。
使用不带任何参数的 cin.get() 可读取下一个字符（任何字符）。或将两个类成员函数合并：cin.get(Name, Size).get()
当 get() 读取空行后将设置失效位。这意味着接下来的输入将被阻断。可以使用 cin.clear 恢复输入

可以使用 string 类型的变量而不是字符数组来存储字符串
string 类位于命名空间 std 中
类设计能让 程序自动处理 string 的大小
不能将一个数组赋给另一个数组，但是可以将一个 string 对象赋给另一个 string 对象
可以使用运算符 + 将两个 string 合并起来，还可以使用 += 将字符串加到 string 对象的末尾

头文件 cstring 提供了函数 strcpy(), strcat(), strlen()
函数 strcpy() 将字符串复制到字符数组中，函数 strcat() 将字符串附加到字符数组末尾
C 函数库提供了 strncat() 和 strncpy()，它们接受指出目标数组最大允许长度的第三个参数
函数 strlen() 是一个常规函数，他接受一个 C 风格字符串作为参数，并返回该字符串包含的字符数
函数 size() 的功能基本上与上面的函数相同，但句法不同，它不接受参数，用句点与对象连接

未初始化的数组内容是未定义的，对于未被初始化的数据，第一个空字符出现的位置是随机的。

C++ 11 新增了类型 char16_t 和 char32_t 
C++ 11 还支持 Unicode 字符编码方案 UTF-8
C++ 11 新增原始（raw）字符串。在原始字符串中，字符表示的就是自己。原始字符串将 " " 用作定界符，并使用前缀 R 来标识原始字符串。使用 R"+* 标识原始字符串的开头时，必须使用 +*" 标识原始字符串的结尾。

创建结构包括两步。首先，定义结构描述——它描述并标记了能够存储在结构中的各种数据类型。然后按照描述创建结构变量（结构数据对象）

关键字 struct 表明，这些代码定义的是一个结构的布局。标识符 inflatabel 是这种数据格式的名称，因此新类型的名称为 inflatabel。接下来的大括号中包含的是结构存储的数据类型的列表，其中每个列表项都是一条声明语句。
struct inflatable
{
    char name[20];
    float volume;
    double price;
}
列表中的每一项都被称为结构成员。结构定义指出了新类型的特征。定义结构后便可以创建这种类型的变量。
C++允许在声明结构变量时省略关键字 struct
可以使用成员运算符 (.) 来访问各个成员

结构初始化，使用逗号分隔值列表，并将这些值用花括号括起。
C++ 11 也支持将列表初始化用于结构，且 = 可以不加。如果大括号内未包含任何东西，各个成员都将被设置为零。不允许缩窄转换。

可以使用赋值运算符将结构赋给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值

可以同时完成定义结构和创建结构变量的工作，只需将变量名方在结束括号的后面即可。
甚至可以直接初始化以这种方式创建的变量
然而，将结构定义和变量声明分开，可以使程序更容易理解和阅读

可以创建元素为结构的数组，方法和创建基本类型数组完全相同
要初始化结构数组，可以结合使用初始化数组的规则和初始化结构的规则

共同体（union）是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型
共同体的用途之一是，当数据项使用两种或更多种格式，但不会同时使用时，可节省空间。
共同体常用于节省内存、操作系统数据结构和硬件数据结构

C++ 的 enum 工具提供了另一种创建符号常量的方式，这种方式可以代替 const。它还允许定义新类型，使用 enum 的句法与使用结构类似：让 spectrum 成为新类型的名称；sptectrum 被称为枚举，就像 struct 变量被称为结构一样。将 red、orange、yellow 等作为符号常量，它们对应整数值 0~7 。这些常量叫做枚举量。在默认情况下，将整数值赋给枚举量，第一个枚举量的值为 0，第二个枚举量的值为 1，依次类推。
可以使用枚举名声明这种类型的变量
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举的变量
对于枚举，只定义了赋值运算符，没有为枚举定义算数运算
枚举量是整型，可被提升为 int 类型。但 int 类型不能转换为枚举类型
没有为枚举定义运算符，枚举在用于算术表达式中时，枚举将被转换为整数
如果 int 值是有效的，则可以通过强制转换类型，将它赋给枚举变量
如果只是打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称
可以使用赋值运算符来显示的设置枚举量的值，指定的值必须是整数。也可以只显示的定义其中一部分枚举量的值，第一个值默认为 0，后面没有被初始化的枚举量的值将比其前面的枚举量大1
可以创建多个值相同的枚举量
C++ 通过强制类型转换，增加了可赋给枚举变量的合法值。每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举变量，即使这个值不是枚举值
取值范围的定义：首先，要找出上限，需要知道枚举量的最大值。找到大于这个最大值的最小的 2 的幂，将它减去 1，得到的便是取值范围的上限。计算下限，需要知道枚举量的最小值。如果它不小于 0，则下限为零；否则，采用与寻找上限相似的方式，再加上符号。
选择用多少空间来存储枚举由编译器来决定。对于取值范围较小的枚举，使用一个字节或更少的空间，而对于包含 long 类型值的枚举，则使用 4 个字节
C++ 11 扩展了枚举，增加了作用域内枚举

内部变量和外部变量

指针是一个变量，其存储的是值的地址，而不是值本身。只需对变量应用地址运算符 &，就可以获得它的位置
将地址视为指定的量，而将值视为派生量。
* 运算符被称为间接值或接触引用运算符，它返回操作数所指向的对象的值，将其应用于指针，可以得到该地址处存储的值
指针声明必须指定指针指向的数据的类型。例：int * p1 , * p2
C++ 中，int* 是一种特殊的类型，是指向 int 的指针
可以在声明语句中初始化指针，初始化的是指针，而不是它指向的值
在C++ 中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。为数据提供空间是一个独立的步骤，不可忽略这一步。这种错误可能会导致一些最隐匿、最难以跟踪的 bug
指针不是整形，指针与整数是截然不同的类型，不能直接将整数赋给指针。要将数字值作为地址使用，应通过强制转换将数字转换为地址类型。

程序员告诉 new，需要为哪种数据类型分配内存；new 将找到一个长度正确的内存块，并返回其地址。程序员将该地址赋给一个指针。
new 分配的内存块通常与常规变量声明分配的内存块不同。常规变量的值存储在被成为栈（stack）的内存区域中，而 new 从被称为堆（heap）或自由存储区（free store）的内存区域分配内存

C++ 中，值为 0 的指针被称为空指针。C++ 确保空指针不会指向有效的数据，因此它常被用来表示运算符或函数失败

当需要内存时，使用 new 来请求，在使用完内存后，使用 delete 运算符，能够将内存归还给内存池。
使用 delete 时，后面加上指向当初用 new 分配的内存块的指针
不能使用 delete 释放不是使用 new 分配的内存。然而对空指针使用是安全的
不要使用 delete 释放同一个内存块两次。可能会出错
创建两个指向同一个内存块的指针，会增加错误的删除同一个内存块两次的可能性
如果使用 new 时，不带方括号，则使用 delete 时，也不应带方括号。如果使用 new 时带方括号，则使用 delete 时也应该带方括号

在编译时给数组分配内存被称为静态联编，意味着数组是在编译时加入到程序中的。但使用 new 时，在运行阶段根据创建的数组大小分配合适的内存，被称为动态联编。

为数组分配内存的通用格式：type_name * pointer_name = new type_name [num_elements];

指针和数组基本等价的原因在于指针算数和 C++ 内部处理数组的方式。
将指针加 1 后，增加的量等于它指向的类型的字节数。
C++ 将数组名解释为数组第 1 个元素的地址
区别之一是，不能修改数组名的值。但指针是变量，因此可以修改它的值。
另一个区别是，对数组应用 sizeof 运算符得到的是数组的长度，而对指针应用 sizeof 得到的是指针的长度，即使指针指向的是一个数组。
数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址
数组名被解释额日期第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址
short (*pas) [20] = & tell;            // 其中 tell 是一个包含 20 个元素的数组
使用方括号数组表示法等同于对指针解除引用

在 cout 和多数 C++ 表达式中，char 数组名、char 指针以及引号括起的字符串常量都被解释为字符串第一个字符的位置

一般来说，编译器在内存留一些空间，以存储程序源代码中所有用引号括起的字符串，并将每个被存储的字符串与其地址关联起来
有些编译器将字符串字面值视为只读常量，如果试图修改它们，将导致运行阶段错误。在C++ 中，字符串字面值都将被视为常量，但并不是所有的编译器都对以前的行为做了这样的修改

在将字符串读入程序时，应使用已分配的内存地址。该地址可以使数组名，也可以是使用 new 初始化过的指针
一般来说，给 cout 提供一个指针，它将打印地址。但如果指针的类型为 char*，则 cout 将显示指向的字符串。如果要显示的是字符串的地址，则必须将这种指针强制转换为另一种指针类型，如 int*

要获得字符串的副本，还需要做其他工作。首先，需要分配内存来存储该字符串，这可以通过声明另一个数组或使用 new 来完成
ps = new char [strlen(animal) + 1]              // ps是声明过的指针，animal是声明过的数组

strncpy() 接受第 3 个参数，要复制的最大字符数。要注意的是，如果该函数在到达字符串结尾之前，目标内存已经用完，则它不会添加空字符，应该手动添加空字符

将 new 用于结构由两步组成：创建结构和访问其成员。要创建结构，需要同时使用结构类型和 new
inflatable * ps = new inflatable；
创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道它的地址。C++ 提供了一个运算符，箭头成员运算符 -> 。改运算符可用于指向结构的指针，就像点运算符可用于结构名一样
另一个访问结构的方法是，如果 ps 是指向结构的指针，则 *ps 就是被指向的值——结构本身。由于 *ps 是一个结构，因此（*ps）.price是该结构的 price 成员。C++ 的运算符优先规则要求使用括号

根据用于分配内存的方法，C++ 有 3 种管理数据内存的方式：自动存储、静态存储和动态存储。C++ 11 新增了第四种类型，线程存储
在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，在函数结束时消亡。
自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将一次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为先进后出（LIFO）。因此在程序执行过程中，栈将不断地增大和缩小

静态存储是整个程序执行期间都存在的存储方式。是变量成为静态的方式有两种：一种是在函数外面定义它；另一种是再声明变量时使用关键字 static 
在 K&R C 中，只能初始化静态数组和静态结构，而 C++ Release 2.0 及后续版本和 ANSI C 中，也可以初始化自动数组和自动结构

new 和 delete 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++ 中被称为自由存储空间或堆。该内存池同用于静态变量和自动变量的内存是分开的。new 和 delete 可以在一个函数中分配内存，在另一个函数中释放它。数据的生命周期不完全受程序或函数的生存时间控制。与使用常规变量相比，使用 new 和 delete 让程序员对程序如何使用内存有更大的控制权。然而，内存管理也更复杂了。在栈中，自动添加和删除机制时的占用的内存总是连续的，但 new 和 delete 的相互影响可能导致占用的自由存储区不连续，这使得跟踪新分配内存的位置更困难

如果使用 new 运算符在自由存储空间（堆）上创建变量后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上分配的变量或结构也将继续存在。实际上，将无法访问自由存储空间中的结构，因为只想这些内存的指针无效。这将导致内存泄漏。被泄露的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。极端情况是，内存泄漏非常严重，以至于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄露还会给一些操作系统或在相同的内存空间中运行的程序带来负面影响，导致它们崩溃

即使是最好的程序员和软件公司，也可能导致内存泄漏，最好的办法是养成同时使用 new 和 delete 的习惯

可以各种方式组合数组、结构和指针

二级指针。这个概念我写不下来，有点绕。

模板类 vector 类似于 string类，也是一种动态数组。可以在运行阶段设置 vector 对象的长度，可以在末尾附加新数据，还可以在中间插入新数据。
使用 vector 对象，必须包含头文件 vector 
vector 包含在名称空间 std 中
模板使用不同的语法指出它存储的数据类型
vector 类使用不同的语法来指定元素数
一般而言，下面的声明创建一个名为 vt 的 vector 对象，它可储存 n_elem 个类型为 typeName 的元素：
vector<typeName> vt(n_elem);
其中 elem 可以是整型常量，也可以是整型变量

C++ 11 新增了模板类 array ，和数组类似，位于 std 中，长度固定，使用栈
下面的声明创建一个名为 arr 的 array 对象，它包含 n_elem 个类型为 typeName 的元素：
array< typeName, n_elem> arr;
与创建 vector 不同的是，n_elem 不能是变量
可以将一个 array 对象赋给另一个 array对象
在 C++ 11 中，可将列表初始化用于 vector 和 array 对象，但在 C++ 98 中，不能对 vector 这样做
可以使用vector 和 array 对象的成员函数 at()
中括号表示法和成员函数 at() 表示法的区别在于，使用 at() 时，将在运行期间捕获非法索引，而程序默认将中断

++ 运算符——递增运算符，它将操作数的值加 1 
递减运算符相似

for 循环的组成部分完成下列步骤：设置初始者；执行测试；执行循环操作；更新用于测试的值。
初始化、测试和更新操作构成了控制部分，由括号括起。其中每一部分都是一个表达式，彼此由分号隔开。控制部分后面的语句叫做循环体，只要测试表达式为 true，它便被执行。
C++ 语法将整个 for 看作一条语句——虽然循环体可以包含一条或多条语句，但被看作一个代码块。
循环只执行一次初始化。通常，程序使用表达式将变量设置为起始值，然后用该变量计算循环周期。
test-expression (测试表达式） 决定循环体是否被执行。通常是关系表达式，对两个值进行比较。
C++ 并没有将 test-expression 的值限制为只能为真或假。可以使用任意表达式，C++ 将把结果强制转换为 bool 类型。因此，值为 0 的表达式将被转换为 bool 值false，导致循环结束。表达式的值非零，将被转换为 bool 值 true，循环将继续进行
for 循环是入口条件（entry-condition）循环。这意味着在每轮循环之前，都将计算测试表达式的值，当测试表达式为 false 时，将不会执行循环体。
update-expression（更新表达式）在每轮循环结束时运行，此时循环体已经执行完毕。通常，它用来对跟踪循环论次的变量的值进行增减。然而，它可以是任何有效的 C++ 表达式，还可以是其他控制表达式
for 是一个 C++ 关键字，因此编译器不会将 for 视为一个函数，这还将防止将函数命名为 for
C++ 常用的方式是在 for 和括号之间加上一个空格，而省略函数名与括号之间的空格
对于其他控制语句（如 if 和 while），处理方式与 for 相似。这样从视觉上强化了控制语句和函数调用之间的区别。另外，常见的做法是缩进 for 语句体，使它看上去比较显著
for 语句的控制部分使用 3 个表达式。由于其自身强加的句法限制，C++ 成为非常具有表现力的语言。
任何值或任何有效的值和运算符的组合都是表达式
在 C++ 中，每个表达式都有值
C++ 将赋值表达式的值定义为左侧表达式的值。这意味着赋值表达式整体部分有一个值。
优先级表表明，赋值运算符是从右向左结合
<< 运算符的优先级比表达式中使用的运算符高。因此有些代码需要使用括号来获得正确的运算顺序
通常，cout 在显式 bool 值之前将他们转换为 int，cout.setf(ios::boolalpha) 函数调用设置了一个标记，该标记命令 cout 显式 true 和 false，而不是 0 和 1
当判定表达式的值这种操作改变了内存中的数据的值时，称表达式有副作用（side effect）。因此，判定赋值表达式会带来这样的副作用，即修改被赋值者的值。
从 C++ 的构造方式来看，判定表达式是主要作用。并不是所有的表达式都有副作用。
从表达式到语句的转变很容易，只要加分好即可。；
只要加上分号，所拥有的表达式都可以成为语句，但不一定有意义。
从语句中删除分号，不一定成为表达式。
返回语句、声明语句、for 语句没有分号
不能把 for 循环赋给变量，for 循环不是表达式，因此没有值，也不能给它赋值
C++ 在 C 的基础上添加了一项特性，C++ 允许这样做：可以在 for 循环的初始化部分中声明变量。这种变量只存在于 for 语句中，离开循环后，这种变量将消失。这很方便，但不适用于原来的句法，因为声明不是表达式。（这里对旧版本的应用理由解释得很奇怪，一时无法理解，先放一放）
可以在循环体中使用循环计数
递增运算符和递减运算符有两种变体。前缀版本位于操作数前面，意味着先加 1，再计算表达式。后缀版本位于操作数后面，先计算表达式，后加 1
副作用指的是在计算表达式时对某些东西进行了修改。顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。在 C++ 中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。另外，任何完整的表达式末尾都是一个顺序点。
不是另一个更大的表达式的子表达式的表达式，是完整表达式。（你猜，你猜我猜不猜，你猜我猜你猜我猜不猜，你猜我猜你猜我猜你猜我猜不猜……？）（我逻辑性好强的说）
在 C++ 11 文档中，不再使用术语顺序点。这个概念难以用于讨论多线程执行。使用了属于顺序，它表示有些事件在其他事件前发生。这种描述方法对之前的概念并未有什么改变。
前缀函数将值加 1，然后返回结果；但后缀版本先复制一个副本，再加 1，然后将副本返回。对于类来说，前缀版本比后缀效率高。
前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。（这个顺序很容易混乱啊）
+= 运算符将两个操作数相加，并将结果赋给左边的操作数。这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构成员或通过指针解除引用来标识的数据。
如果要在循环体中包含多条语句，用两个花括号来构造一条复合语句（代码块）。代码块由一对花括号和它们包含的语句组成，被视为一条语句，从而满足句法的要求。
复合语句还有一种有趣的特性。如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完该语句块后，变量将被释放。
如果在一个语句块中声明一个变量，而外部语句块中也有一个同样名称的变量，在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量。然后旧变量再次可见。
语句块允许把两条或更多条语句放到 C++ 句法只能放一条语句的地方。逗号运算符对表达式完成同样的任务，允许将两个表达式放到 C++ 句法只允许放一个表达式的地方
逗号不总是逗号运算符
逗号运算符另外两个特性是：首先它确保先计算第一个表达式，然后计算第二个表达式，话句话说，逗号运算符是一个顺序点
其次，C++ 规定，逗号表达式的值是第二部分的值
在所有运算符中，逗号运算符的优先级是最低的
C++ 提供了 6 种关系运算符来对数字进行比较。由于字符用 ASCII 码表示，因此也可以将这些运算符用于字符。不能将它们用于 C-风格字符串，但可用于 string 类对象。对所有的关系表达式，如果比较结果为真，则其值为 true，否则为 false，因此可以将其用作循环测试表达式。老式实现认为结果为 true 的关系表达式的值为 1，而结果为 false 的关系表达式为 0
关系运算符的优先级比算术运算符低
C-风格字符串被视为地址，可使用C-风格字符串库中的 strcmp() 函数来比较。该函数接受两个字符串地址作为参数。这意味着参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该函数返回零；如果第一个字符串按字母顺序排在第二个字符串之前，则返回一个负数值；如果第一个字符串按字母顺序排在第二个字符串之后，则返回一个正数值。字符是根据字符的系统编码来进行比较的，如使用 ASCII 码时，所有大写字母的编码都比小写字母小
有些语言中，存储在不同数组中的字符串彼此不相等。但是 C-风格字符串是通过结尾的空值字符定义的，而不是其所在数组的长度定义的。这意味着两个字符串即使被存储在长度不同的数组中也可能是相同的。

string 类字符串能够使用关系运算符进行比较，函数重载了这些运算符。

while 循环是没有初始化和更新部分的 for 循环，它只有测试条件和循环体
首先程序计算圆括号内的测试条件表达式。如果表达式为 true，则执行循环体中的语句。与 for 循环一样，循环体也由一条语句或两个花括号定义的语句块组成。执行完循环体后，程序返回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环体。测试和执行将一直进行下去，直到测试条件为 false 为止
while 循环也是一种入口条件循环。因此，如果测试条件一开始便为 false，则程序将不会执行循环体
空值字符编码为 0 或 false
不同于 C-风格字符串，string 对象不使用空字符来标记字符串末尾
 
在 C++ 中，for 和 while 循环本质上是相同的
for 循环需要 3 个表达式（专业的说是 1 条后面跟两个表达式的语句），他们可以是空表达式（语句），两个分号必须有。省略 for 循环中的测试表达式时，测试结果将为 true，下面的循环将一直运行下去。如果循环体中包含 continue 语句，情况有些不同。通常程序员使用 for 循环作计数循环，在无法得知循环执行次数的时候，使用 while 循环
设计循环的原则：指定循环终止的条件；在首次测试之前初始化条件；在条件被再次测试之前更新条件

C++ 为类型建立别名的方式有两种。一种是使用预处理器：#define BYTE char 
这样预处理器将在编译程序时使用 char 替换所有的 BYTE，从而使 BYTE 成为 char 的别名
第二种方法是使用 C++ （和 C）的关键字 typedef 来创建别名。例如，typedef char type；

do while 循环，是出口条件循环。这意味着这种循环将先执行循环体，然后再判定测试表达式，决定是否应继续执行循环。如果条件为 false，则循环终止；否则进入新一轮的执行和测试。这样的循环通常至少执行一次，因为其程序流必须经过循环体后才能到达测试条件
循环体是一条语句或用括号括起的语句块

C++ 11 新增了一种循环：基于范围的 for 循环。这简化了一种常见的循环任务——对数组（或容器类，如 vector 和 array）的每个元素执行相同的操作
要修改数组的元素需要使用不同的循环变量语法
还可以结合使用基于范围的 for 循环和初始化列表

读取 char 值时，与读取其他基本类型一样，cin 将忽略空格和换行符。
发送给 cin 的输入被缓冲。这意味着只有在用户按下回车后，他输入的内容才会被发送给程序
成员函数 cin.get(ch) 读取输入的下一个字符（包括空格），并将其赋给变量 ch
cin.get(ch) 调用将一个值放在 ch 变量中，这意味着将修改该变量的值。在 C 语言中，修改变量的值必须将变量的地址传递给参数。但在 C++ 中，只要函数将参数声明为引用即可。引用是 C++ 在 C 的语言基础上新增的一种类型。头文件 iostream 将 cinget(ch) 的参数声明为引用类型，因此该函数可以修改其参数的值

cin.get() 有多个版本。其中之一，接受两个参数：数组名（字符串的地址）和 int 类型的整数（尺寸）
另外的版本接受一个参数。在C++ 中，支持被称为函数重载的 OOP 特性。
函数重载允许创建多个同名函数，条件是它们的参数列表不同。

检测文件尾（EOF）。C++ 输出工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。
很多操作系统（包括 Unix、Linux 和 Windows 命令提示符模式）都支持重定向，允许用文件替换键盘输入。
很多操作系统都允许通过键盘来模拟文件尾条件
检测到 EOF 后，cin 将两位（eofbit 和 failbit）都设置为 1。可以通过成员函数 eof() 来查看 eofbit 是否被设置；如果检测到 EOF，则 cin.eof() 将返回 bool 值 ture，否则返回 false。同样，如果eofbit 或 failbit 被设置为 1，fail() 将返回 true，否则返回 false。
应将 cin.eof() 或 cin.fail() 放在文件或键盘输入读取后。

cin 方法检测到 EOF 时，将设置 cin 对象中一个指示 EOF 条件的标记。设置这个标记后，cin 将不再读取输入，在次调用 cin 也不管用。对于文件输入，这是有道理的，因为程序不应读取超出文件尾的内容。然而，对于键盘输入，有可能使用模拟 EOF 来结束循环，但稍后要读取其他输入。cin.clear() 方法可能清楚 EOF 标记，使输出继续进行。

！运算符可以将 true 切换为 false 或将 false 切换为 true

方法 cin.get(char) 的返回值是一个 cin 对象。（在C++ 中，输入输出是通过类的方式实现的，形式上有点像普通的类，cin 和 cout 相当于输入输出这个类的对象，而 getchar(),，putchar() 相当于这个类的成员函数,用对象调用成员函数，于是就是 cin.getchar()，该成员函数的作用是从键盘读入一个字符，并把它的值给 cin 这个对象,所以返回的确是 cin 这个对象，但 cin 的值就是用户从键盘输入的字符。）
然而，iostream 提供了一个可以将 iostream对象转换为 bool 值的函数；当 cin 出现在需要 bool 值的地方时，改转换函数将被调用。另外，如果最后一次读取成功了，则转换到的 bool 值为 true；否则为 false。这意味着可以直接使用这样的代买： while (cin)

C 语言中的字符 I/O 函数——getchar() 和 putchar()，它们仍然适用，但要包含头文件 stdio.h 或 cstdio
getchar() 和 cin.get() 相似，getchar() 将字符编码作为 int 值返回；而 cin.get(ch) 返回一个 cin 对象，而不是读取的字符。可以使用cout.put() 函数来显示它的字符，其参数类型为 char，int类型可能会出错。putchar() 函数和它相似，其参数类型为 int
C++标准要求 put() 成员只有一个原型 put(char)。但很多 C++ 实现提供了 3 个原型：put(char), put(unsigned char), put(signed char)。此时向 put() 传递一个 int 值将导致错误，因为转换 int 的类型不止一种
 
当 cin.get() 函数到达 EOF 时，将没有可返回的字符。相反，cin.get() 将返回一个用符号常量 EOF 表示的特殊值。该常量时在头文件 iostream 中定义的。EOF 的值必须不同于任何有效的字符值，以便程序不会将 EOF 与常规字符混淆。通常，EOF 被定义为值 -1，因为没有 ASCII 码为 -1 的字符，但并不需要知道实际的值，而只需在程序中使用 EOF 即可。
由于 EOF 表示的不是有效字符编码，因此可能不与 char 类型兼容。有些系统中 char 类型是没有符号的，因此 char 变量不可能为 EOF类型（-1）。由于这种原因，使用 cin.get() （没有参数）测试 EOF，必须将返回值赋给 int 变量，而不是 char 变量。另外，如果 ch 的类型声明为 int 而不是 char，则必须在 put() 显示 ch 时强制转换为 char 类型

!= 运算符的优先级高于 = 

使用 cin.get(ch) 进行输入时，将不会导致任何类型方面的问题。因为它不会将任何值赋给 ch，只会返回一个 cin 对象
使用字符参数的版本更符合对象方式，可以将它们拼接起来。函数调用 cin.get(ch1) 返回一个 cin 对象，然后便可以通过该对象调用 get(cin2)
get() 的主要用途是能够将 stdio.h 的 getchar() 和 putchar() 转换为 iostream 的 cin.get() 和 cout.put() 方法。头文件用 iostream 替换 stdio.h，并用作用相似的方法替换所有的 getchar() 和 putchar() 即可。

C++ 没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组。因此需要使用两个下表来访问元素，可以认为第一个下标表示行，第二个下标表示列。假设要打印数组所有的内容，可以使用一个 for 循环来改变行，用另一个被嵌套的 for 循环来改变列
创建二位数组时，可以初始化其所有元素。这项技术建立在一维数组初始化技术的基础之上：提供由逗号分隔的用花括号括起的值列表；初始化由一系列花括号括起逗号分割的一维数组初始化组成。
如果可能的话，每行数据各占一行，阅读起来容易。
从存储空间的角度来说，使用指针数组更为经济。然而，如果要修改其中的任何一个字符串，则二维数组是更好的选择。
另外还可以使用 string 对象数组，在希望字符串是可修改的情况下，string 类自动调整大小的特性使这种方法比使用二维数组更为方便

决定是否执行某个操作时，通常使用 if 语句来实现。if 有两种格式：if 和 else if。如果测试条件为 true，则 if 语句将引导程序执行语句或语句块，如果条件是 false，程序将跳过这条语句或语句块。因此，if 语句让程序能够决定是否应执行特定的语句。
